# Tableau de substitution S
# S = [
#     [0xE, 0x4, 0xD, 0x1, 0x2, 0xF, 0xB, 0x8, 0x3, 0xA, 0x6, 0xC, 0x5, 0x9, 0x0, 0x7],
#     # [0x5, 0xC, 0x1, 0xE, 0x7, 0x9, 0xB, 0x2, 0x3, 0x0, 0x4, 0xD, 0xA, 0x6, 0x8, 0xF],
#     # [0x3, 0xD, 0x8, 0x4, 0xC, 0x1, 0xA, 0x7, 0x2, 0xF, 0x6, 0xE, 0x9, 0xB, 0x5, 0x0],
#     # [0x6, 0xB, 0xF, 0x0, 0xA, 0x9, 0x5, 0x1, 0xD, 0xE, 0x8, 0x7, 0x4, 0x2, 0x3, 0xC],
#     # [0xC, 0x1, 0xA, 0xF, 0x9, 0x2, 0x6, 0x8, 0x0, 0xD, 0x3, 0x4, 0xE, 0x7, 0x5, 0xB],
#     # [0x7, 0xE, 0xD, 0x3, 0x0, 0x6, 0x9, 0xA, 0x1, 0x2, 0x8, 0x5, 0xB, 0xC, 0x4, 0xF],
#     # [0xD, 0xC, 0xB, 0x7, 0xE, 0x0, 0x5, 0xA, 0x3, 0x4, 0x2, 0xF, 0x8, 0x9, 0x1, 0x6],
#     # [0x4, 0x3, 0x2, 0xC, 0x9, 0x5, 0xF, 0xA, 0xB, 0xE, 0x1, 0x7, 0x6, 0x0, 0x8, 0xD]
# ]

substitution = {
    '0': 'E',
    '1': '4',
    '2': 'D',
    '3': '1',
    '4': '2',
    '5': 'F',
    '6': 'B',
    '7': '8',
    '8': '3',
    '9': 'A',
    'A': '6',
    'B': 'C',
    'C': '5',
    'D': '9',
    'E': '0',
    'F': '7'
}

output = substitution['5'] #Pour avoir substi de 5

def permutation(input_bits):
    # Créer la liste de la permutation
    perm = [1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15, 4, 8, 12, 16]
    # Initialiser la liste de bits de sortie
    output_bits = [0] * 4
    # Appliquer la permutation aux bits d'entrée
    for i in range(16):
        output_bits[i] = input_bits[perm[i]-1]
    return output_bits

# La fonction permutation prend en entrée une liste de 16 bits et renvoie une liste de 16 bits correspondant 
# à la permutation de l'entrée. La variable perm représente la permutation sous forme de liste, où chaque 
# élément de la liste représente la position de l'élément correspondant dans la permutation. 
# Par exemple, perm[0] est 1, ce qui signifie que le premier élément de la permutation est à la position 1. 
# La boucle for parcourt la liste de permutation et applique la permutation aux bits d'entrée en utilisant 
# la formule output_bits[i] = input_bits[perm[i]-1]. On soustrait 1 de perm[i] pour obtenir l'indice réel 
# dans la liste input_bits.

# Il est important de noter que la permutation spécifiée est sa propre permutation inverse, ce qui signifie 
# qu'appliquer la permutation à nouveau inversera les bits de sortie pour renvoyer les bits d'entrée d'origine.

def fun_Ki(k, i):
    x1, x2, x3, x4 = (k >> 12) & 0xF, (k >> 8) & 0xF, (k >> 4) & 0xF, k & 0xF
    if i == 1 :
        return x = x1

def F(k, x):
    # Découper le bloc x en 4 mots de 4 bits
    x1, x2, x3, x4 = (x >> 12) & 0xF, (x >> 8) & 0xF, (x >> 4) & 0xF, x & 0xF
    
    # Il y a 4 tours

    for i in range(4):
        y1, y2, y3, y4 = x ^ fun_Ki(k,i) #XOR en py esr ^ askip